{"version":3,"file":"eleva-router.min.js","sources":["../src/index.js"],"sourcesContent":["/**\n * @class Router\n * @classdesc A Router Plugin for Eleva.js with Multiple Routing Modes\n *\n * This plugin provides client-side routing functionality for Eleva.js applications.\n * It supports hash-based (e.g. \"#pageName\"), query-based (e.g. \"?page=pageName\"),\n * and history-based (e.g. \"/pageName\") routing. The routing mode is configurable via\n * the plugin options.\n *\n * In addition to injecting route information (current path, query parameters,\n * and full URL) directly into the component's setup context as `route`, this plugin\n * also injects a `navigate` function so developers can programmatically navigate from within components.\n *\n * @param {Object} eleva - The Eleva instance.\n * @param {Object} options - Router configuration options.\n * @param {HTMLElement} options.container - The DOM element where routed components will be mounted.\n * @param {string} [options.mode=\"hash\"] - The routing mode (\"hash\", \"query\", or \"history\").\n * @param {Array<Object>} options.routes - An array of route objects. Each route object should have:\n *   - {string} path - The URL path (e.g. \"/\" or \"/about\").\n *   - {string|Object} component - The component name (if registered globally) or a component definition.\n *   - {Object} [props] - Additional props to pass to the component.\n * @param {Object} [options.defaultRoute] - A default route object used when no route matches.\n */\nclass Router {\n  constructor(eleva, options = {}) {\n    this.eleva = eleva;\n    this.container = options.container;\n    if (!this.container) {\n      throw new Error(\"Router requires a container DOM element in options.\");\n    }\n    this.routes = options.routes || [];\n    this.mode = options.mode || \"hash\"; // \"hash\", \"query\", or \"history\"\n    this.defaultRoute = options.defaultRoute || null;\n  }\n\n  /**\n   * Starts the router by setting up event listeners and resolving the initial route.\n   * @returns {void}\n   */\n  start() {\n    if (this.mode === \"hash\") {\n      window.addEventListener(\"hashchange\", () => this.routeChanged());\n    } else if (this.mode === \"query\" || this.mode === \"history\") {\n      window.addEventListener(\"popstate\", () => this.routeChanged());\n    } else {\n      throw new Error(`Invalid routing mode: ${this.mode}`);\n    }\n    // Resolve the initial route.\n    this.routeChanged();\n  }\n\n  /**\n   * Called when the route changes. Extracts the current route based on the routing mode,\n   * parses the URL query, and mounts the corresponding component. Injects route data and\n   * a navigation function directly into the component's setup context.\n   * @returns {void}\n   */\n  routeChanged() {\n    let path, queryString, fullUrl;\n    if (this.mode === \"hash\") {\n      fullUrl = window.location.href;\n      let hash = window.location.hash.slice(1) || \"\";\n      [path, queryString] = hash.split(\"?\");\n      // If path is empty, default to \"/\"\n      path = path || \"/\";\n    } else if (this.mode === \"query\") {\n      fullUrl = window.location.href;\n      const search = window.location.search; // e.g. ?page=about&foo=bar\n      const urlParams = new URLSearchParams(search);\n      path = urlParams.get(\"page\") || \"\";\n      urlParams.delete(\"page\");\n      queryString = urlParams.toString();\n      path = path || \"/\";\n    } else if (this.mode === \"history\") {\n      fullUrl = window.location.href;\n      path = window.location.pathname || \"/\";\n      queryString = window.location.search\n        ? window.location.search.slice(1)\n        : \"\";\n    } else {\n      throw new Error(\"Invalid router mode: \" + this.mode);\n    }\n    // Normalize the path: Ensure it starts with '/'\n    if (path.charAt(0) !== \"/\") {\n      path = \"/\" + path;\n    }\n    const query = this.parseQuery(queryString);\n    // Try to find a matching route for the current path.\n    let route = this.matchRoute(path);\n    // Use defaultRoute if no matching route is found.\n    if (!route && this.defaultRoute) {\n      route = this.defaultRoute;\n    }\n    if (route) {\n      const wrappedComponent = this.wrapComponentWithRoute(route.component, {\n        path,\n        query,\n        fullUrl,\n      });\n      const props = route.props || {};\n      // For all modes, clear the container before mounting the new route.\n      this.container.innerHTML = \"\";\n      this.eleva.mount(this.container, wrappedComponent, props);\n    }\n  }\n\n  /**\n   * Parses a query string into an object.\n   * @param {string} queryString - The query string portion of a URL.\n   * @returns {Object} An object containing key-value pairs for query parameters.\n   */\n  parseQuery(queryString) {\n    const query = {};\n    if (!queryString) return query;\n    queryString.split(\"&\").forEach((pair) => {\n      const [key, value] = pair.split(\"=\");\n      if (key) {\n        query[decodeURIComponent(key)] = value ? decodeURIComponent(value) : \"\";\n      }\n    });\n    return query;\n  }\n\n  /**\n   * Finds a matching route for the specified path.\n   * @param {string} path - The current path extracted from the URL.\n   * @returns {Object|undefined} The matching route object, or undefined if no match is found.\n   */\n  matchRoute(path) {\n    return this.routes.find((route) => route.path === path);\n  }\n\n  /**\n   * Programmatically navigates to the specified route.\n   * Updates the URL based on the routing mode and triggers route resolution.\n   * @param {string} path - The target route path.\n   * @returns {void}\n   */\n  navigate(path) {\n    if (this.mode === \"hash\") {\n      // In hash mode, if navigating to home (\"/\"), remove the hash entirely.\n      if (path === \"/\" || path === \"\") {\n        // Remove the hash entirely using replaceState and update the view.\n        history.replaceState(\n          null,\n          \"\",\n          window.location.pathname + window.location.search\n        );\n        this.routeChanged();\n      } else {\n        window.location.hash = path;\n      }\n    } else if (this.mode === \"query\") {\n      const urlParams = new URLSearchParams(window.location.search);\n      if (path === \"/\" || path === \"\") {\n        urlParams.delete(\"page\");\n      } else {\n        urlParams.set(\"page\", path);\n      }\n      const newQuery = urlParams.toString();\n      const newUrl =\n        window.location.pathname + (newQuery ? \"?\" + newQuery : \"\");\n      history.pushState({}, \"\", newUrl);\n      this.routeChanged();\n    } else if (this.mode === \"history\") {\n      history.pushState({}, \"\", path);\n      this.routeChanged();\n    }\n  }\n\n  /**\n   * Adds a new route to the router.\n   * @param {Object} route - The route object to add.\n   * @returns {void}\n   */\n  addRoute(route) {\n    this.routes.push(route);\n  }\n\n  /**\n   * Wraps a component definition so that its setup function receives the route information\n   * and the navigate function directly in the context.\n   * @param {string|Object} comp - The component name (if registered globally) or component definition.\n   * @param {Object} routeInfo - An object containing route information (path, query, fullUrl).\n   * @returns {Object} A new component definition with an augmented setup function.\n   */\n  wrapComponentWithRoute(comp, routeInfo) {\n    let definition = comp;\n    if (typeof comp === \"string\") {\n      definition = this.eleva._components[comp];\n      if (!definition) {\n        throw new Error(`Component \"${comp}\" not registered.`);\n      }\n    }\n    // Create a shallow copy of the component definition.\n    const wrapped = { ...definition };\n    const originalSetup = wrapped.setup;\n\n    // Override the setup function to inject route information\n    wrapped.setup = (ctx) => {\n      ctx.route = routeInfo;\n      ctx.navigate = this.navigate.bind(this);\n      // Inject route information and navigation function into the context.\n      return originalSetup ? originalSetup(ctx) : {};\n    };\n\n    // If this component has children, we need to modify its children handling\n    if (wrapped.children) {\n      const originalChildren = { ...wrapped.children };\n      wrapped.children = {};\n\n      // For each child component, wrap it to also include route information\n      Object.keys(originalChildren).forEach((childKey) => {\n        const childComp = originalChildren[childKey];\n        wrapped.children[childKey] = this.wrapComponentWithRoute(\n          childComp,\n          routeInfo\n        );\n      });\n    }\n\n    return wrapped;\n  }\n}\n\n/**\n * @typedef {Object} RouteDefinition\n * @property {string} path - The URL path (e.g., \"/\" or \"/about\").\n * @property {string|Object} component - The component name (if registered globally) or a component definition.\n * @property {Object} [props] - Additional properties to pass to the routed component.\n */\n\n/**\n * @typedef {Object} RouterOptions\n * @property {HTMLElement} container - The DOM element where routed components will be mounted.\n * @property {string} [mode=\"hash\"] - The routing mode: \"hash\", \"query\", or \"history\".\n * @property {Array<RouteDefinition>} routes - An array of route definitions.\n * @property {RouteDefinition} [defaultRoute] - A default route object to use when no route matches.\n */\n\n/**\n * @namespace ElevaRouter\n * @description ElevaRouter is the official router plugin for Eleva.js.\n *\n * It provides client-side routing\n * functionality with support for multiple routing modes, automatic component registration, and route\n * information injection into the setup context.\n *\n * Installs the ElevaRouter plugin into an Eleva.js instance.\n * Automatically registers routed components if provided as definitions.\n *\n * @param {Object} eleva - The Eleva instance.\n * @param {RouterOptions} options - Router configuration options.\n * @returns {void}\n */\nconst ElevaRouter = {\n  install(eleva, options = {}) {\n    // Automatically register routed components if provided as definitions.\n    const routes = options.routes || [];\n    let autoRegCounter = 0;\n    routes.forEach((route) => {\n      if (typeof route.component === \"object\") {\n        let compName = route.component.name;\n        if (!compName) {\n          compName = \"AutoRegComponent_\" + autoRegCounter++;\n        }\n        eleva.component(compName, route.component);\n        route.component = compName;\n      }\n    });\n    const router = new Router(eleva, options);\n    eleva.router = router;\n    router.start();\n  },\n};\n\nexport default ElevaRouter;\n"],"names":["Router","constructor","eleva","options","this","container","Error","routes","mode","defaultRoute","start","window","addEventListener","routeChanged","path","queryString","fullUrl","location","href","hash","slice","split","search","urlParams","URLSearchParams","get","delete","toString","pathname","charAt","query","parseQuery","route","matchRoute","wrappedComponent","wrapComponentWithRoute","component","props","innerHTML","mount","forEach","pair","key","value","decodeURIComponent","find","navigate","history","replaceState","set","newQuery","newUrl","pushState","addRoute","push","comp","routeInfo","definition","_components","wrapped","originalSetup","setup","ctx","bind","children","originalChildren","Object","keys","childKey","childComp","install","autoRegCounter","compName","name","router"],"mappings":"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"}