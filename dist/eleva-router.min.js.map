{"version":3,"file":"eleva-router.min.js","sources":["../src/index.js"],"sourcesContent":["/**\n * @class Router\n * @classdesc A router for Eleva.js that supports multiple routing modes:\n * \"hash\", \"query\", and \"history\". It extracts the current route information\n * (path, query parameters, full URL) and injects it into routed components'\n * setup context along with a `navigate` function.\n *\n * @param {Object} eleva - The Eleva instance.\n * @param {Object} options - Router configuration options.\n * @param {HTMLElement} options.container - The DOM element where routed components will be mounted.\n * @param {string} [options.mode=\"hash\"] - The routing mode (\"hash\", \"query\", or \"history\").\n * @param {Array<Object>} options.routes - An array of route objects. Each route object should have:\n *   - {string} path - The URL path (e.g. \"/\" or \"/about\").\n *   - {string|Object} component - The component name (if registered globally) or a component definition.\n *   - {Object} [props] - Additional props to pass to the component.\n * @param {Object} [options.defaultRoute] - A default route object used when no route matches.\n */\nclass Router {\n  constructor(eleva, options = {}) {\n    this.eleva = eleva;\n    this.container = options.container;\n    if (!this.container) {\n      throw new Error(\"Router requires a container DOM element in options.\");\n    }\n    this.routes = options.routes || [];\n    this.mode = options.mode || \"hash\"; // \"hash\", \"query\", or \"history\"\n    this.defaultRoute = options.defaultRoute || null;\n  }\n\n  /**\n   * Starts the router by setting up event listeners and resolving the initial route.\n   * @returns {void}\n   */\n  start() {\n    if (this.mode === \"hash\") {\n      window.addEventListener(\"hashchange\", () => this.routeChanged());\n    } else if (this.mode === \"query\" || this.mode === \"history\") {\n      window.addEventListener(\"popstate\", () => this.routeChanged());\n    } else {\n      throw new Error(`Invalid routing mode: ${this.mode}`);\n    }\n    // Resolve the initial route.\n    this.routeChanged();\n  }\n\n  /**\n   * Called when the route changes. Extracts the current route based on the routing mode,\n   * parses the URL query, and mounts the corresponding component. Injects route data and\n   * a navigation function directly into the component's setup context.\n   * @returns {void}\n   */\n  routeChanged() {\n    let path, queryString, fullUrl;\n    if (this.mode === \"hash\") {\n      fullUrl = window.location.href;\n      let hash = window.location.hash.slice(1) || \"/\";\n      [path, queryString] = hash.split(\"?\");\n      path = path || \"/\";\n    } else if (this.mode === \"query\") {\n      fullUrl = window.location.href;\n      const search = window.location.search; // e.g. ?page=about&foo=bar\n      const urlParams = new URLSearchParams(search);\n      path = urlParams.get(\"page\") || \"/\";\n      urlParams.delete(\"page\");\n      queryString = urlParams.toString();\n    } else if (this.mode === \"history\") {\n      fullUrl = window.location.href;\n      path = window.location.pathname || \"/\";\n      queryString = window.location.search\n        ? window.location.search.slice(1)\n        : \"\";\n    } else {\n      throw new Error(\"Invalid router mode: \" + this.mode);\n    }\n    const query = this.parseQuery(queryString);\n    // Try to find a matching route for the current path.\n    let route = this.matchRoute(path);\n    // Use defaultRoute if no matching route is found.\n    if (!route && this.defaultRoute) {\n      route = this.defaultRoute;\n    }\n    if (route) {\n      const wrappedComponent = this.wrapComponentWithRoute(route.component, {\n        path,\n        query,\n        fullUrl,\n      });\n      const props = route.props || {};\n      this.eleva.mount(this.container, wrappedComponent, props);\n    }\n  }\n\n  /**\n   * Parses a query string into an object.\n   * @param {string} queryString - The query string portion of a URL.\n   * @returns {Object} An object containing key-value pairs for query parameters.\n   */\n  parseQuery(queryString) {\n    const query = {};\n    if (!queryString) return query;\n    queryString.split(\"&\").forEach((pair) => {\n      const [key, value] = pair.split(\"=\");\n      if (key) {\n        query[decodeURIComponent(key)] = value ? decodeURIComponent(value) : \"\";\n      }\n    });\n    return query;\n  }\n\n  /**\n   * Finds a matching route for the specified path.\n   * @param {string} path - The current path extracted from the URL.\n   * @returns {Object|undefined} The matching route object, or undefined if no match is found.\n   */\n  matchRoute(path) {\n    return this.routes.find((route) => route.path === path);\n  }\n\n  /**\n   * Programmatically navigates to the specified route.\n   * Updates the URL based on the routing mode and triggers route resolution.\n   * @param {string} path - The target route path.\n   * @returns {void}\n   */\n  navigate(path) {\n    if (this.mode === \"hash\") {\n      window.location.hash = path;\n    } else if (this.mode === \"query\") {\n      const urlParams = new URLSearchParams(window.location.search);\n      urlParams.set(\"page\", path);\n      const newUrl = window.location.pathname + \"?\" + urlParams.toString();\n      history.pushState({}, \"\", newUrl);\n      this.routeChanged();\n    } else if (this.mode === \"history\") {\n      history.pushState({}, \"\", path);\n      this.routeChanged();\n    }\n  }\n\n  /**\n   * Adds a new route to the router.\n   * @param {Object} route - The route object to add.\n   * @returns {void}\n   */\n  addRoute(route) {\n    this.routes.push(route);\n  }\n\n  /**\n   * Wraps a component definition so that its setup function receives the route information\n   * and the navigate function directly in the context.\n   * @param {string|Object} comp - The component name (if registered globally) or component definition.\n   * @param {Object} routeInfo - An object containing route information (path, query, fullUrl).\n   * @returns {Object} A new component definition with an augmented setup function.\n   */\n  wrapComponentWithRoute(comp, routeInfo) {\n    let definition = comp;\n    if (typeof comp === \"string\") {\n      definition = this.eleva._components[comp];\n      if (!definition) {\n        throw new Error(`Component \"${comp}\" not registered.`);\n      }\n    }\n    // Create a shallow copy of the component definition.\n    const wrapped = { ...definition };\n    const originalSetup = wrapped.setup;\n    wrapped.setup = (ctx) => {\n      const data = originalSetup ? originalSetup(ctx) : {};\n      // Inject route information and navigation function into the context.\n      return Object.assign({}, data, {\n        route: routeInfo,\n        navigate: this.navigate.bind(this),\n      });\n    };\n    return wrapped;\n  }\n}\n\n/**\n * @typedef {Object} RouteDefinition\n * @property {string} path - The URL path (e.g., \"/\" or \"/about\").\n * @property {string|Object} component - The component name (if registered globally) or component definition.\n * @property {Object} [props] - Additional properties to pass to the routed component.\n */\n\n/**\n * @typedef {Object} RouterOptions\n * @property {HTMLElement} container - The DOM element where routed components will be mounted.\n * @property {string} [mode=\"hash\"] - The routing mode: \"hash\", \"query\", or \"history\".\n * @property {Array<RouteDefinition>} routes - An array of route definitions.\n * @property {RouteDefinition} [defaultRoute] - A default route object to use when no route matches.\n */\n\n/**\n * @namespace ElevaRouter\n * @description ElevaRouter is the official router plugin for Eleva.js. It provides client-side routing\n * functionality with support for multiple routing modes, automatic component registration, and route\n * information injection into the setup context.\n */\nconst ElevaRouter = {\n  /**\n   * Installs the ElevaRouter plugin into an Eleva.js instance.\n   * Automatically registers routed components if provided as definitions.\n   *\n   * @param {Object} eleva - The Eleva instance.\n   * @param {RouterOptions} options - Router configuration options.\n   * @returns {void}\n   *\n   * @example\n   * import Eleva from \"eleva\";\n   * import ElevaRouter from \"@eleva/router\";\n   *\n   * const app = new Eleva(\"MyApp\");\n   *\n   * const HomeComponent = {\n   *   setup: ({ route }) => {\n   *     console.log(\"Current route:\", route.path);\n   *     return {};\n   *   },\n   *   template: () => `<div>Welcome Home!</div>`\n   * };\n   *\n   * const AboutComponent = {\n   *   setup: ({ route, navigate }) => {\n   *     function goHome() { navigate(\"/\"); }\n   *     return { goHome };\n   *   },\n   *   template: (ctx) => `\n   *     <div>\n   *       <h1>About Us</h1>\n   *       <button @click=\"goHome\">Go Home</button>\n   *     </div>\n   *   `\n   * };\n   *\n   * const NotFoundComponent = {\n   *   setup: ({ route, navigate }) => ({ goHome: () => navigate(\"/\") }),\n   *   template: (ctx) => `\n   *     <div>\n   *       <h1>404 - Not Found</h1>\n   *       <button @click=\"goHome\">Return Home</button>\n   *     </div>\n   *   `\n   * };\n   *\n   * app.use(ElevaRouter, {\n   *   container: document.getElementById(\"view\"),\n   *   mode: \"history\", // \"hash\", \"query\", or \"history\"\n   *   routes: [\n   *     { path: \"/\", component: HomeComponent },\n   *     { path: \"/about\", component: AboutComponent }\n   *   ],\n   *   defaultRoute: { path: \"/404\", component: NotFoundComponent }\n   * });\n   *\n   * // Navigate programmatically:\n   * app.router.navigate(\"/about\");\n   */\n  install(eleva, options = {}) {\n    // Automatically register routed components if provided as definitions.\n    const routes = options.routes || [];\n    let autoRegCounter = 0;\n    routes.forEach((route) => {\n      if (typeof route.component === \"object\") {\n        let compName = route.component.name;\n        if (!compName) {\n          compName = \"AutoRegComponent_\" + autoRegCounter++;\n        }\n        eleva.component(compName, route.component);\n        route.component = compName;\n      }\n    });\n    const router = new Router(eleva, options);\n    eleva.router = router;\n    router.start();\n  },\n};\n\nexport default ElevaRouter;\n"],"names":["Router","constructor","eleva","options","this","container","Error","routes","mode","defaultRoute","start","window","addEventListener","routeChanged","path","queryString","fullUrl","location","href","hash","slice","split","search","urlParams","URLSearchParams","get","delete","toString","pathname","query","parseQuery","route","matchRoute","wrappedComponent","wrapComponentWithRoute","component","props","mount","forEach","pair","key","value","decodeURIComponent","find","navigate","set","newUrl","history","pushState","addRoute","push","comp","routeInfo","definition","_components","wrapped","originalSetup","setup","ctx","data","Object","assign","bind","install","autoRegCounter","compName","name","router"],"mappings":"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"}