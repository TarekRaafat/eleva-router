{"version":3,"file":"eleva-router.esm.js","sources":["../src/index.js"],"sourcesContent":["/**\n * @class Router\n * @classdesc A Router Plugin for Eleva.js with Multiple Routing Modes\n *\n * This plugin provides client-side routing functionality for Eleva.js applications.\n * It supports hash-based (e.g. \"#pageName\"), query-based (e.g. \"?page=pageName\"),\n * and history-based (e.g. \"/pageName\") routing. The routing mode is configurable via\n * the plugin options.\n *\n * In addition to injecting route information (current path, query parameters,\n * and full URL) directly into the component's setup context as `route`, this plugin\n * also injects a `navigate` function so developers can programmatically navigate from within components.\n *\n * The router now supports dynamic route parameters (e.g. \"/users/:id\") which are passed\n * to the component via the route.params object.\n *\n * @param {Object} eleva - The Eleva instance.\n * @param {Object} options - Router configuration options.\n * @param {HTMLElement} options.layout - The app layout DOM element. The router will look for a view element\n *   (#{viewSelector} id, .{viewSelector} class, <{viewSelector}> element, or data-{viewSelector} attribute) within this layout to mount routed components.\n *   Priority is based on selection speed from fastest to slowest (micro-optimization). If no view element is found, the layout element itself will be used as the mounting target.\n * @param {string} [options.mode=\"hash\"] - The routing mode (\"hash\", \"query\", or \"history\").\n * @param {Array<Object>} options.routes - An array of route objects. Each route object should have:\n *   - {string} path - The URL path (e.g. \"/\" or \"/about\" or \"/users/:id\").\n *   - {string|Object} component - The component name (if registered globally) or a component definition.\n *   - {Object} [props] - Additional props to pass to the component.\n * @param {string} [options.queryParam=\"page\"] - The query parameter to use for routing.\n * @param {string} [options.viewSelector=\"view\"] - The selector name for the view element. Used to find elements like #{viewSelector}, .{viewSelector}, <{viewSelector}>, or data-{viewSelector}.\n * @param {Object} [options.defaultRoute] - A default route object used when no route matches.\n */\nclass Router {\n  constructor(eleva, options = {}) {\n    this.eleva = eleva;\n    this.layout = options.layout;\n    if (!this.layout) {\n      throw new Error(\"Router requires a layout DOM element in options.\");\n    }\n\n    // Find the view element within the layout, or use layout as fallback\n    this.viewSelector = options.viewSelector || \"view\"; // Default view selector\n    this.view =\n      this.layout.querySelector(`#${this.viewSelector}`) ||\n      this.layout.querySelector(`.${this.viewSelector}`) ||\n      this.layout.querySelector(this.viewSelector) ||\n      this.layout.querySelector(`[data-${this.viewSelector}]`) ||\n      this.layout;\n\n    this.routes = options.routes || [];\n    this.mode = options.mode || \"hash\"; // \"hash\", \"query\", or \"history\"\n    this.queryParam = options.queryParam || \"page\"; // The query parameter to use for routing\n    this.defaultRoute = options.defaultRoute || null;\n    this.eventListeners = []; // Track event listeners for cleanup\n    this.isStarted = false; // Track router state\n\n    // Validate routing mode\n    if (![\"hash\", \"query\", \"history\"].includes(this.mode)) {\n      throw new Error(\n        `Invalid routing mode: ${this.mode}. Must be \"hash\", \"query\", or \"history\".`\n      );\n    }\n\n    // Preprocess routes to identify parameter segments\n    this.routes = this.routes.map((route) => {\n      return {\n        ...route,\n        segments: this.parsePathIntoSegments(route.path),\n      };\n    });\n  }\n\n  /**\n   * Parses a path into segments for efficient parameter matching.\n   * @param {string} path - The route path pattern (e.g. \"/users/:id/profile\").\n   * @returns {Array} An array of segment objects with type and value.\n   * @private\n   */\n  parsePathIntoSegments(path) {\n    if (!path || typeof path !== \"string\") {\n      throw new Error(\"Route path must be a non-empty string\");\n    }\n\n    return path\n      .split(\"/\")\n      .filter(Boolean)\n      .map((segment) => {\n        if (segment.startsWith(\":\")) {\n          return { type: \"param\", name: segment.substring(1) };\n        }\n        return { type: \"static\", value: segment };\n      });\n  }\n\n  /**\n   * Starts the router by setting up event listeners and resolving the initial route.\n   * @returns {Promise<void>}\n   */\n  async start() {\n    if (this.isStarted) {\n      console.warn(\"Router is already started\");\n      return;\n    }\n\n    try {\n      if (this.mode === \"hash\") {\n        const hashHandler = async () => await this.routeChanged();\n        window.addEventListener(\"hashchange\", hashHandler);\n        this.eventListeners.push(() =>\n          window.removeEventListener(\"hashchange\", hashHandler)\n        );\n      } else if (this.mode === \"query\" || this.mode === \"history\") {\n        const popstateHandler = async () => await this.routeChanged();\n        window.addEventListener(\"popstate\", popstateHandler);\n        this.eventListeners.push(() =>\n          window.removeEventListener(\"popstate\", popstateHandler)\n        );\n      }\n\n      this.isStarted = true;\n      // Resolve the initial route\n      await this.routeChanged();\n    } catch (error) {\n      console.error(\"Failed to start router:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Stops the router and cleans up event listeners.\n   * @returns {Promise<void>}\n   */\n  async destroy() {\n    if (!this.isStarted) {\n      return;\n    }\n\n    try {\n      // Clean up event listeners\n      this.eventListeners.forEach((cleanup) => cleanup());\n      this.eventListeners = [];\n\n      // Unmount current component\n      const existingInstance = this.view._eleva_instance;\n      if (existingInstance) {\n        await existingInstance.unmount();\n      }\n\n      this.isStarted = false;\n    } catch (error) {\n      console.error(\"Error destroying router:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Called when the route changes. Extracts the current route based on the routing mode,\n   * parses the URL query, and mounts the corresponding component. Injects route data and\n   * a navigation function directly into the component's setup context.\n   * @returns {Promise<void>}\n   */\n  async routeChanged() {\n    try {\n      let path, queryString, fullUrl;\n\n      if (this.mode === \"hash\") {\n        fullUrl = window.location.href;\n        let hash = window.location.hash.slice(1) || \"\";\n        [path, queryString] = hash.split(\"?\");\n        // If path is empty, default to \"/\"\n        path = path || \"/\";\n      } else if (this.mode === \"query\") {\n        fullUrl = window.location.href;\n        const search = window.location.search; // e.g. ?page=about&foo=bar\n        const urlParams = new URLSearchParams(search);\n        path = urlParams.get(this.queryParam) || \"\";\n        urlParams.delete(this.queryParam);\n        queryString = urlParams.toString();\n        path = path || \"/\";\n      } else if (this.mode === \"history\") {\n        fullUrl = window.location.href;\n        path = window.location.pathname || \"/\";\n        queryString = window.location.search\n          ? window.location.search.slice(1)\n          : \"\";\n      }\n\n      // Normalize the path: Ensure it starts with '/'\n      if (path.charAt(0) !== \"/\") {\n        path = \"/\" + path;\n      }\n\n      // Unmount the previous component instance if it exists\n      const existingInstance = this.view._eleva_instance;\n      if (existingInstance) {\n        try {\n          await existingInstance.unmount();\n        } catch (error) {\n          console.warn(\"Error unmounting previous component:\", error);\n        }\n      }\n\n      const query = this.parseQuery(queryString);\n\n      // Try to find a matching route for the current path\n      const matchResult = this.matchRoute(path);\n\n      // Use defaultRoute if no matching route is found\n      if (!matchResult && this.defaultRoute) {\n        try {\n          const wrappedComponent = this.wrapComponentWithRoute(\n            this.defaultRoute.component,\n            {\n              path,\n              query,\n              fullUrl,\n              params: {},\n              matchedRoute: this.defaultRoute.path,\n            }\n          );\n          const props = this.defaultRoute.props || {};\n          await this.eleva.mount(this.view, wrappedComponent, props);\n        } catch (error) {\n          console.error(\"Error mounting default route component:\", error);\n        }\n      } else if (matchResult) {\n        try {\n          const { route, params } = matchResult;\n          const wrappedComponent = this.wrapComponentWithRoute(\n            route.component,\n            {\n              path,\n              query,\n              fullUrl,\n              params,\n              matchedRoute: route.path,\n            }\n          );\n          const props = route.props || {};\n          await this.eleva.mount(this.view, wrappedComponent, props);\n        } catch (error) {\n          console.error(\"Error mounting route component:\", error);\n        }\n      } else {\n        console.warn(`No route found for path: ${path}`);\n      }\n    } catch (error) {\n      console.error(\"Error in route change:\", error);\n    }\n  }\n\n  /**\n   * Parses a query string into an object.\n   * @param {string} queryString - The query string portion of a URL.\n   * @returns {Object} An object containing key-value pairs for query parameters.\n   */\n  parseQuery(queryString) {\n    const query = {};\n    if (!queryString) return query;\n\n    try {\n      queryString.split(\"&\").forEach((pair) => {\n        const [key, value] = pair.split(\"=\");\n        if (key) {\n          query[decodeURIComponent(key)] = value\n            ? decodeURIComponent(value)\n            : \"\";\n        }\n      });\n    } catch (error) {\n      console.warn(\"Error parsing query string:\", error);\n    }\n\n    return query;\n  }\n\n  /**\n   * Finds a matching route for the specified path.\n   * Supports dynamic route parameters (e.g. \"/users/:id\").\n   * @param {string} path - The current path extracted from the URL.\n   * @returns {Object|null} An object containing the matched route and extracted parameters, or null if no match is found.\n   */\n  matchRoute(path) {\n    // Input validation\n    if (!path || typeof path !== \"string\") {\n      console.warn(\"Invalid path provided to matchRoute:\", path);\n      return null;\n    }\n\n    try {\n      // Handle root path special case\n      if (path === \"/\") {\n        const rootRoute = this.routes.find((route) => route.path === \"/\");\n        if (rootRoute) {\n          return { route: rootRoute, params: {} };\n        }\n        return null;\n      }\n\n      // Split the current path into segments for matching\n      const pathSegments = path.split(\"/\").filter(Boolean);\n\n      // Try to match against all routes\n      for (const route of this.routes) {\n        try {\n          // Skip the root route as we've already handled it\n          if (route.path === \"/\") continue;\n\n          const routeSegments = route.segments;\n\n          // Quick length check (except for catch-all routes with wildcard segments)\n          const hasCatchAll = routeSegments.some(\n            (s) => s.type === \"param\" && s.name.endsWith(\"*\")\n          );\n          if (!hasCatchAll && routeSegments.length !== pathSegments.length) {\n            continue;\n          }\n\n          // Try to match segment by segment\n          const params = {};\n          let isMatch = true;\n\n          for (let i = 0; i < routeSegments.length; i++) {\n            const routeSegment = routeSegments[i];\n            const pathSegment = pathSegments[i];\n\n            // Path is shorter than route definition\n            if (pathSegment === undefined) {\n              isMatch = false;\n              break;\n            }\n\n            if (routeSegment.type === \"static\") {\n              // For static segments, direct comparison\n              if (routeSegment.value !== pathSegment) {\n                isMatch = false;\n                break;\n              }\n            } else if (routeSegment.type === \"param\") {\n              // Handle catch-all parameters (e.g. \":path*\")\n              if (routeSegment.name.endsWith(\"*\")) {\n                const paramName = routeSegment.name.slice(0, -1);\n                params[paramName] = pathSegments.slice(i).join(\"/\");\n                break; // This will match all remaining segments\n              }\n\n              // For parameter segments, store the value\n              params[routeSegment.name] = pathSegment;\n            }\n          }\n\n          if (isMatch) {\n            return { route, params };\n          }\n        } catch (error) {\n          console.warn(`Error matching route ${route.path}:`, error);\n          continue;\n        }\n      }\n\n      return null;\n    } catch (error) {\n      console.error(\"Error in matchRoute:\", error);\n      return null;\n    }\n  }\n\n  /**\n   * Programmatically navigates to the specified route.\n   * Updates the URL based on the routing mode and triggers route resolution.\n   * @param {string} path - The target route path.\n   * @param {Object} [params] - Route parameters to inject into the path.\n   * @returns {Promise<void>}\n   */\n  async navigate(path, params = {}) {\n    if (!path || typeof path !== \"string\") {\n      console.error(\"Invalid path provided to navigate:\", path);\n      return;\n    }\n\n    try {\n      // If params are provided, replace parameter placeholders in the path\n      if (params && Object.keys(params).length > 0) {\n        Object.keys(params).forEach((key) => {\n          path = path.replace(`:${key}`, encodeURIComponent(params[key]));\n        });\n      }\n\n      if (this.mode === \"hash\") {\n        if (path === \"/\" || path === \"\") {\n          // For root path, clear hash completely\n          window.location.hash = \"\";\n        } else {\n          // For other paths, set hash (this triggers hashchange automatically)\n          window.location.hash = path;\n        }\n      } else if (this.mode === \"query\") {\n        const urlParams = new URLSearchParams(window.location.search);\n        if (path === \"/\" || path === \"\") {\n          urlParams.delete(this.queryParam);\n        } else {\n          urlParams.set(this.queryParam, path);\n        }\n        const newQuery = urlParams.toString();\n        const newUrl =\n          window.location.pathname + (newQuery ? \"?\" + newQuery : \"\");\n        history.pushState({}, \"\", newUrl);\n        await this.routeChanged();\n      } else if (this.mode === \"history\") {\n        history.pushState({}, \"\", path);\n        await this.routeChanged();\n      }\n    } catch (error) {\n      console.error(\"Error navigating to path:\", path, error);\n    }\n  }\n\n  /**\n   * Adds a new route to the router.\n   * @param {Object} route - The route object to add.\n   * @returns {void}\n   */\n  addRoute(route) {\n    if (!route || !route.path || !route.component) {\n      throw new Error(\"Route must have both 'path' and 'component' properties\");\n    }\n\n    try {\n      // Preprocess the route to identify parameter segments\n      route.segments = this.parsePathIntoSegments(route.path);\n      this.routes.push(route);\n    } catch (error) {\n      console.error(\"Error adding route:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Wraps a component definition so that its setup function receives the route information\n   * and the navigate function directly in the context.\n   * @param {string|Object} comp - The component name (if registered globally) or component definition.\n   * @param {Object} routeInfo - An object containing route information (path, query, fullUrl, params).\n   * @returns {Object} A new component definition with an augmented setup function.\n   */\n  wrapComponentWithRoute(comp, routeInfo) {\n    let definition;\n    if (typeof comp === \"string\") {\n      definition = this.eleva._components.get(comp);\n      if (!definition) {\n        throw new Error(`Component \"${comp}\" not registered.`);\n      }\n    } else {\n      definition = comp;\n    }\n\n    // Create a shallow copy of the component definition\n    const wrapped = { ...definition };\n    const originalSetup = wrapped.setup;\n\n    // Override the setup function to inject route information\n    wrapped.setup = (ctx) => {\n      ctx.route = routeInfo;\n      // Bind navigate with the router instance and wrap it to support params\n      const originalNavigate = this.navigate.bind(this);\n      ctx.navigate = (path, params) => originalNavigate(path, params);\n      // Inject route information and navigation function into the context\n      return originalSetup ? originalSetup(ctx) : {};\n    };\n\n    // If this component has children, we need to modify its children handling\n    if (wrapped.children) {\n      const originalChildren = { ...wrapped.children };\n      wrapped.children = {};\n\n      // For each child component, wrap it to also include route information\n      Object.keys(originalChildren).forEach((childKey) => {\n        const childComp = originalChildren[childKey];\n        wrapped.children[childKey] = this.wrapComponentWithRoute(\n          childComp,\n          routeInfo\n        );\n      });\n    }\n\n    return wrapped;\n  }\n}\n\n/**\n * @typedef {Object} RouteDefinition\n * @property {string} path - The URL path (e.g., \"/\" or \"/about\" or \"/users/:id\").\n * @property {string|Object} component - The component name (if registered globally) or a component definition.\n * @property {Object} [props] - Additional properties to pass to the routed component.\n */\n\n/**\n * @typedef {Object} RouterOptions\n * @property {HTMLElement} layout - The app layout DOM element. The router will look for a view element\n *   (with data-view attribute, .view class, or #view id) within this layout to mount routed components.\n *   If no view element is found, the layout element itself will be used as the mounting target.\n * @property {string} [mode=\"hash\"] - The routing mode: \"hash\", \"query\", or \"history\".\n * @property {Array<RouteDefinition>} routes - An array of route definitions.\n * @property {RouteDefinition} [defaultRoute] - A default route object to use when no route matches.\n * @property {boolean} [autoStart=true] - Whether to automatically start the router.\n * If set to false, the router must be manually started using eleva.router.start().\n */\n\n/**\n * @namespace ElevaRouter\n * @description ElevaRouter is the official router plugin for Eleva.js.\n *\n * It provides client-side routing functionality with support for multiple routing modes,\n * automatic component registration, and route information injection into the setup context.\n *\n * Installs the ElevaRouter plugin into an Eleva.js instance.\n * Automatically registers routed components if provided as definitions.\n *\n * @param {Object} eleva - The Eleva instance.\n * @param {RouterOptions} options - Router configuration options.\n * @param {boolean} [options.autoStart=true] - Whether to automatically start the router.\n * If set to false, the router must be manually started using eleva.router.start().\n * @returns {void}\n */\nconst ElevaRouter = {\n  name: \"ElevaRouter\",\n  install(eleva, options = {}) {\n    try {\n      // Automatically register routed components if provided as definitions\n      const routes = options.routes || [];\n      let autoRegCounter = 0;\n\n      routes.forEach((route) => {\n        if (typeof route.component === \"object\") {\n          let compName = route.component.name;\n          if (!compName) {\n            compName = \"AutoRegComponent_\" + autoRegCounter++;\n          }\n          eleva.component(compName, route.component);\n          route.component = compName;\n        }\n      });\n\n      const router = new Router(eleva, options);\n      eleva.router = router;\n\n      // Handle auto-start asynchronously without blocking plugin installation\n      const shouldAutoStart = options.autoStart !== false;\n      if (shouldAutoStart) {\n        queueMicrotask(async () => {\n          try {\n            await router.start();\n          } catch (error) {\n            console.error(\"Failed to auto-start router:\", error);\n          }\n        });\n      }\n    } catch (error) {\n      console.error(\"Failed to install ElevaRouter plugin:\", error);\n      throw error;\n    }\n  },\n};\n\nexport default ElevaRouter;\n"],"names":["Router","constructor","eleva","options","layout","Error","viewSelector","view","querySelector","routes","mode","queryParam","defaultRoute","eventListeners","isStarted","includes","map","route","segments","parsePathIntoSegments","path","split","filter","Boolean","segment","startsWith","type","name","substring","value","start","console","warn","hashHandler","routeChanged","window","addEventListener","push","removeEventListener","popstateHandler","error","destroy","forEach","cleanup","existingInstance","_eleva_instance","unmount","queryString","fullUrl","location","href","hash","slice","search","urlParams","URLSearchParams","get","delete","toString","pathname","charAt","query","parseQuery","matchResult","matchRoute","wrappedComponent","wrapComponentWithRoute","component","params","matchedRoute","props","mount","pair","key","decodeURIComponent","rootRoute","find","pathSegments","routeSegments","hasCatchAll","some","s","endsWith","length","isMatch","i","routeSegment","pathSegment","undefined","paramName","join","navigate","Object","keys","replace","encodeURIComponent","set","newQuery","newUrl","history","pushState","addRoute","comp","routeInfo","definition","_components","wrapped","originalSetup","setup","ctx","originalNavigate","bind","children","originalChildren","childKey","childComp","ElevaRouter","install","autoRegCounter","compName","router","shouldAutoStart","autoStart","queueMicrotask"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMA,MAAM,CAAC;AACXC,EAAAA,WAAWA,CAACC,KAAK,EAAEC,OAAO,GAAG,EAAE,EAAE;IAC/B,IAAI,CAACD,KAAK,GAAGA,KAAK;AAClB,IAAA,IAAI,CAACE,MAAM,GAAGD,OAAO,CAACC,MAAM;AAC5B,IAAA,IAAI,CAAC,IAAI,CAACA,MAAM,EAAE;AAChB,MAAA,MAAM,IAAIC,KAAK,CAAC,kDAAkD,CAAC;AACrE,IAAA;;AAEA;IACA,IAAI,CAACC,YAAY,GAAGH,OAAO,CAACG,YAAY,IAAI,MAAM,CAAC;IACnD,IAAI,CAACC,IAAI,GACP,IAAI,CAACH,MAAM,CAACI,aAAa,CAAC,CAAA,CAAA,EAAI,IAAI,CAACF,YAAY,CAAA,CAAE,CAAC,IAClD,IAAI,CAACF,MAAM,CAACI,aAAa,CAAC,CAAA,CAAA,EAAI,IAAI,CAACF,YAAY,CAAA,CAAE,CAAC,IAClD,IAAI,CAACF,MAAM,CAACI,aAAa,CAAC,IAAI,CAACF,YAAY,CAAC,IAC5C,IAAI,CAACF,MAAM,CAACI,aAAa,CAAC,CAAA,MAAA,EAAS,IAAI,CAACF,YAAY,CAAA,CAAA,CAAG,CAAC,IACxD,IAAI,CAACF,MAAM;AAEb,IAAA,IAAI,CAACK,MAAM,GAAGN,OAAO,CAACM,MAAM,IAAI,EAAE;IAClC,IAAI,CAACC,IAAI,GAAGP,OAAO,CAACO,IAAI,IAAI,MAAM,CAAC;IACnC,IAAI,CAACC,UAAU,GAAGR,OAAO,CAACQ,UAAU,IAAI,MAAM,CAAC;AAC/C,IAAA,IAAI,CAACC,YAAY,GAAGT,OAAO,CAACS,YAAY,IAAI,IAAI;AAChD,IAAA,IAAI,CAACC,cAAc,GAAG,EAAE,CAAC;AACzB,IAAA,IAAI,CAACC,SAAS,GAAG,KAAK,CAAC;;AAEvB;AACA,IAAA,IAAI,CAAC,CAAC,MAAM,EAAE,OAAO,EAAE,SAAS,CAAC,CAACC,QAAQ,CAAC,IAAI,CAACL,IAAI,CAAC,EAAE;MACrD,MAAM,IAAIL,KAAK,CACb,CAAA,sBAAA,EAAyB,IAAI,CAACK,IAAI,0CACpC,CAAC;AACH,IAAA;;AAEA;IACA,IAAI,CAACD,MAAM,GAAG,IAAI,CAACA,MAAM,CAACO,GAAG,CAAEC,KAAK,IAAK;MACvC,OAAO;AACL,QAAA,GAAGA,KAAK;AACRC,QAAAA,QAAQ,EAAE,IAAI,CAACC,qBAAqB,CAACF,KAAK,CAACG,IAAI;OAChD;AACH,IAAA,CAAC,CAAC;AACJ,EAAA;;AAEA;AACF;AACA;AACA;AACA;AACA;EACED,qBAAqBA,CAACC,IAAI,EAAE;AAC1B,IAAA,IAAI,CAACA,IAAI,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;AACrC,MAAA,MAAM,IAAIf,KAAK,CAAC,uCAAuC,CAAC;AAC1D,IAAA;AAEA,IAAA,OAAOe,IAAI,CACRC,KAAK,CAAC,GAAG,CAAC,CACVC,MAAM,CAACC,OAAO,CAAC,CACfP,GAAG,CAAEQ,OAAO,IAAK;AAChB,MAAA,IAAIA,OAAO,CAACC,UAAU,CAAC,GAAG,CAAC,EAAE;QAC3B,OAAO;AAAEC,UAAAA,IAAI,EAAE,OAAO;AAAEC,UAAAA,IAAI,EAAEH,OAAO,CAACI,SAAS,CAAC,CAAC;SAAG;AACtD,MAAA;MACA,OAAO;AAAEF,QAAAA,IAAI,EAAE,QAAQ;AAAEG,QAAAA,KAAK,EAAEL;OAAS;AAC3C,IAAA,CAAC,CAAC;AACN,EAAA;;AAEA;AACF;AACA;AACA;EACE,MAAMM,KAAKA,GAAG;IACZ,IAAI,IAAI,CAAChB,SAAS,EAAE;AAClBiB,MAAAA,OAAO,CAACC,IAAI,CAAC,2BAA2B,CAAC;AACzC,MAAA;AACF,IAAA;IAEA,IAAI;AACF,MAAA,IAAI,IAAI,CAACtB,IAAI,KAAK,MAAM,EAAE;QACxB,MAAMuB,WAAW,GAAG,YAAY,MAAM,IAAI,CAACC,YAAY,EAAE;AACzDC,QAAAA,MAAM,CAACC,gBAAgB,CAAC,YAAY,EAAEH,WAAW,CAAC;AAClD,QAAA,IAAI,CAACpB,cAAc,CAACwB,IAAI,CAAC,MACvBF,MAAM,CAACG,mBAAmB,CAAC,YAAY,EAAEL,WAAW,CACtD,CAAC;AACH,MAAA,CAAC,MAAM,IAAI,IAAI,CAACvB,IAAI,KAAK,OAAO,IAAI,IAAI,CAACA,IAAI,KAAK,SAAS,EAAE;QAC3D,MAAM6B,eAAe,GAAG,YAAY,MAAM,IAAI,CAACL,YAAY,EAAE;AAC7DC,QAAAA,MAAM,CAACC,gBAAgB,CAAC,UAAU,EAAEG,eAAe,CAAC;AACpD,QAAA,IAAI,CAAC1B,cAAc,CAACwB,IAAI,CAAC,MACvBF,MAAM,CAACG,mBAAmB,CAAC,UAAU,EAAEC,eAAe,CACxD,CAAC;AACH,MAAA;MAEA,IAAI,CAACzB,SAAS,GAAG,IAAI;AACrB;AACA,MAAA,MAAM,IAAI,CAACoB,YAAY,EAAE;IAC3B,CAAC,CAAC,OAAOM,KAAK,EAAE;AACdT,MAAAA,OAAO,CAACS,KAAK,CAAC,yBAAyB,EAAEA,KAAK,CAAC;AAC/C,MAAA,MAAMA,KAAK;AACb,IAAA;AACF,EAAA;;AAEA;AACF;AACA;AACA;EACE,MAAMC,OAAOA,GAAG;AACd,IAAA,IAAI,CAAC,IAAI,CAAC3B,SAAS,EAAE;AACnB,MAAA;AACF,IAAA;IAEA,IAAI;AACF;MACA,IAAI,CAACD,cAAc,CAAC6B,OAAO,CAAEC,OAAO,IAAKA,OAAO,EAAE,CAAC;MACnD,IAAI,CAAC9B,cAAc,GAAG,EAAE;;AAExB;AACA,MAAA,MAAM+B,gBAAgB,GAAG,IAAI,CAACrC,IAAI,CAACsC,eAAe;AAClD,MAAA,IAAID,gBAAgB,EAAE;AACpB,QAAA,MAAMA,gBAAgB,CAACE,OAAO,EAAE;AAClC,MAAA;MAEA,IAAI,CAAChC,SAAS,GAAG,KAAK;IACxB,CAAC,CAAC,OAAO0B,KAAK,EAAE;AACdT,MAAAA,OAAO,CAACS,KAAK,CAAC,0BAA0B,EAAEA,KAAK,CAAC;AAChD,MAAA,MAAMA,KAAK;AACb,IAAA;AACF,EAAA;;AAEA;AACF;AACA;AACA;AACA;AACA;EACE,MAAMN,YAAYA,GAAG;IACnB,IAAI;AACF,MAAA,IAAId,IAAI,EAAE2B,WAAW,EAAEC,OAAO;AAE9B,MAAA,IAAI,IAAI,CAACtC,IAAI,KAAK,MAAM,EAAE;AACxBsC,QAAAA,OAAO,GAAGb,MAAM,CAACc,QAAQ,CAACC,IAAI;AAC9B,QAAA,IAAIC,IAAI,GAAGhB,MAAM,CAACc,QAAQ,CAACE,IAAI,CAACC,KAAK,CAAC,CAAC,CAAC,IAAI,EAAE;QAC9C,CAAChC,IAAI,EAAE2B,WAAW,CAAC,GAAGI,IAAI,CAAC9B,KAAK,CAAC,GAAG,CAAC;AACrC;QACAD,IAAI,GAAGA,IAAI,IAAI,GAAG;AACpB,MAAA,CAAC,MAAM,IAAI,IAAI,CAACV,IAAI,KAAK,OAAO,EAAE;AAChCsC,QAAAA,OAAO,GAAGb,MAAM,CAACc,QAAQ,CAACC,IAAI;QAC9B,MAAMG,MAAM,GAAGlB,MAAM,CAACc,QAAQ,CAACI,MAAM,CAAC;AACtC,QAAA,MAAMC,SAAS,GAAG,IAAIC,eAAe,CAACF,MAAM,CAAC;QAC7CjC,IAAI,GAAGkC,SAAS,CAACE,GAAG,CAAC,IAAI,CAAC7C,UAAU,CAAC,IAAI,EAAE;AAC3C2C,QAAAA,SAAS,CAACG,MAAM,CAAC,IAAI,CAAC9C,UAAU,CAAC;AACjCoC,QAAAA,WAAW,GAAGO,SAAS,CAACI,QAAQ,EAAE;QAClCtC,IAAI,GAAGA,IAAI,IAAI,GAAG;AACpB,MAAA,CAAC,MAAM,IAAI,IAAI,CAACV,IAAI,KAAK,SAAS,EAAE;AAClCsC,QAAAA,OAAO,GAAGb,MAAM,CAACc,QAAQ,CAACC,IAAI;AAC9B9B,QAAAA,IAAI,GAAGe,MAAM,CAACc,QAAQ,CAACU,QAAQ,IAAI,GAAG;AACtCZ,QAAAA,WAAW,GAAGZ,MAAM,CAACc,QAAQ,CAACI,MAAM,GAChClB,MAAM,CAACc,QAAQ,CAACI,MAAM,CAACD,KAAK,CAAC,CAAC,CAAC,GAC/B,EAAE;AACR,MAAA;;AAEA;MACA,IAAIhC,IAAI,CAACwC,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;QAC1BxC,IAAI,GAAG,GAAG,GAAGA,IAAI;AACnB,MAAA;;AAEA;AACA,MAAA,MAAMwB,gBAAgB,GAAG,IAAI,CAACrC,IAAI,CAACsC,eAAe;AAClD,MAAA,IAAID,gBAAgB,EAAE;QACpB,IAAI;AACF,UAAA,MAAMA,gBAAgB,CAACE,OAAO,EAAE;QAClC,CAAC,CAAC,OAAON,KAAK,EAAE;AACdT,UAAAA,OAAO,CAACC,IAAI,CAAC,sCAAsC,EAAEQ,KAAK,CAAC;AAC7D,QAAA;AACF,MAAA;AAEA,MAAA,MAAMqB,KAAK,GAAG,IAAI,CAACC,UAAU,CAACf,WAAW,CAAC;;AAE1C;AACA,MAAA,MAAMgB,WAAW,GAAG,IAAI,CAACC,UAAU,CAAC5C,IAAI,CAAC;;AAEzC;AACA,MAAA,IAAI,CAAC2C,WAAW,IAAI,IAAI,CAACnD,YAAY,EAAE;QACrC,IAAI;UACF,MAAMqD,gBAAgB,GAAG,IAAI,CAACC,sBAAsB,CAClD,IAAI,CAACtD,YAAY,CAACuD,SAAS,EAC3B;YACE/C,IAAI;YACJyC,KAAK;YACLb,OAAO;YACPoB,MAAM,EAAE,EAAE;AACVC,YAAAA,YAAY,EAAE,IAAI,CAACzD,YAAY,CAACQ;AAClC,WACF,CAAC;UACD,MAAMkD,KAAK,GAAG,IAAI,CAAC1D,YAAY,CAAC0D,KAAK,IAAI,EAAE;AAC3C,UAAA,MAAM,IAAI,CAACpE,KAAK,CAACqE,KAAK,CAAC,IAAI,CAAChE,IAAI,EAAE0D,gBAAgB,EAAEK,KAAK,CAAC;QAC5D,CAAC,CAAC,OAAO9B,KAAK,EAAE;AACdT,UAAAA,OAAO,CAACS,KAAK,CAAC,yCAAyC,EAAEA,KAAK,CAAC;AACjE,QAAA;MACF,CAAC,MAAM,IAAIuB,WAAW,EAAE;QACtB,IAAI;UACF,MAAM;YAAE9C,KAAK;AAAEmD,YAAAA;AAAO,WAAC,GAAGL,WAAW;UACrC,MAAME,gBAAgB,GAAG,IAAI,CAACC,sBAAsB,CAClDjD,KAAK,CAACkD,SAAS,EACf;YACE/C,IAAI;YACJyC,KAAK;YACLb,OAAO;YACPoB,MAAM;YACNC,YAAY,EAAEpD,KAAK,CAACG;AACtB,WACF,CAAC;AACD,UAAA,MAAMkD,KAAK,GAAGrD,KAAK,CAACqD,KAAK,IAAI,EAAE;AAC/B,UAAA,MAAM,IAAI,CAACpE,KAAK,CAACqE,KAAK,CAAC,IAAI,CAAChE,IAAI,EAAE0D,gBAAgB,EAAEK,KAAK,CAAC;QAC5D,CAAC,CAAC,OAAO9B,KAAK,EAAE;AACdT,UAAAA,OAAO,CAACS,KAAK,CAAC,iCAAiC,EAAEA,KAAK,CAAC;AACzD,QAAA;AACF,MAAA,CAAC,MAAM;AACLT,QAAAA,OAAO,CAACC,IAAI,CAAC,CAAA,yBAAA,EAA4BZ,IAAI,EAAE,CAAC;AAClD,MAAA;IACF,CAAC,CAAC,OAAOoB,KAAK,EAAE;AACdT,MAAAA,OAAO,CAACS,KAAK,CAAC,wBAAwB,EAAEA,KAAK,CAAC;AAChD,IAAA;AACF,EAAA;;AAEA;AACF;AACA;AACA;AACA;EACEsB,UAAUA,CAACf,WAAW,EAAE;IACtB,MAAMc,KAAK,GAAG,EAAE;AAChB,IAAA,IAAI,CAACd,WAAW,EAAE,OAAOc,KAAK;IAE9B,IAAI;MACFd,WAAW,CAAC1B,KAAK,CAAC,GAAG,CAAC,CAACqB,OAAO,CAAE8B,IAAI,IAAK;QACvC,MAAM,CAACC,GAAG,EAAE5C,KAAK,CAAC,GAAG2C,IAAI,CAACnD,KAAK,CAAC,GAAG,CAAC;AACpC,QAAA,IAAIoD,GAAG,EAAE;AACPZ,UAAAA,KAAK,CAACa,kBAAkB,CAACD,GAAG,CAAC,CAAC,GAAG5C,KAAK,GAClC6C,kBAAkB,CAAC7C,KAAK,CAAC,GACzB,EAAE;AACR,QAAA;AACF,MAAA,CAAC,CAAC;IACJ,CAAC,CAAC,OAAOW,KAAK,EAAE;AACdT,MAAAA,OAAO,CAACC,IAAI,CAAC,6BAA6B,EAAEQ,KAAK,CAAC;AACpD,IAAA;AAEA,IAAA,OAAOqB,KAAK;AACd,EAAA;;AAEA;AACF;AACA;AACA;AACA;AACA;EACEG,UAAUA,CAAC5C,IAAI,EAAE;AACf;AACA,IAAA,IAAI,CAACA,IAAI,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;AACrCW,MAAAA,OAAO,CAACC,IAAI,CAAC,sCAAsC,EAAEZ,IAAI,CAAC;AAC1D,MAAA,OAAO,IAAI;AACb,IAAA;IAEA,IAAI;AACF;MACA,IAAIA,IAAI,KAAK,GAAG,EAAE;AAChB,QAAA,MAAMuD,SAAS,GAAG,IAAI,CAAClE,MAAM,CAACmE,IAAI,CAAE3D,KAAK,IAAKA,KAAK,CAACG,IAAI,KAAK,GAAG,CAAC;AACjE,QAAA,IAAIuD,SAAS,EAAE;UACb,OAAO;AAAE1D,YAAAA,KAAK,EAAE0D,SAAS;AAAEP,YAAAA,MAAM,EAAE;WAAI;AACzC,QAAA;AACA,QAAA,OAAO,IAAI;AACb,MAAA;;AAEA;AACA,MAAA,MAAMS,YAAY,GAAGzD,IAAI,CAACC,KAAK,CAAC,GAAG,CAAC,CAACC,MAAM,CAACC,OAAO,CAAC;;AAEpD;AACA,MAAA,KAAK,MAAMN,KAAK,IAAI,IAAI,CAACR,MAAM,EAAE;QAC/B,IAAI;AACF;AACA,UAAA,IAAIQ,KAAK,CAACG,IAAI,KAAK,GAAG,EAAE;AAExB,UAAA,MAAM0D,aAAa,GAAG7D,KAAK,CAACC,QAAQ;;AAEpC;UACA,MAAM6D,WAAW,GAAGD,aAAa,CAACE,IAAI,CACnCC,CAAC,IAAKA,CAAC,CAACvD,IAAI,KAAK,OAAO,IAAIuD,CAAC,CAACtD,IAAI,CAACuD,QAAQ,CAAC,GAAG,CAClD,CAAC;UACD,IAAI,CAACH,WAAW,IAAID,aAAa,CAACK,MAAM,KAAKN,YAAY,CAACM,MAAM,EAAE;AAChE,YAAA;AACF,UAAA;;AAEA;UACA,MAAMf,MAAM,GAAG,EAAE;UACjB,IAAIgB,OAAO,GAAG,IAAI;AAElB,UAAA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGP,aAAa,CAACK,MAAM,EAAEE,CAAC,EAAE,EAAE;AAC7C,YAAA,MAAMC,YAAY,GAAGR,aAAa,CAACO,CAAC,CAAC;AACrC,YAAA,MAAME,WAAW,GAAGV,YAAY,CAACQ,CAAC,CAAC;;AAEnC;YACA,IAAIE,WAAW,KAAKC,SAAS,EAAE;AAC7BJ,cAAAA,OAAO,GAAG,KAAK;AACf,cAAA;AACF,YAAA;AAEA,YAAA,IAAIE,YAAY,CAAC5D,IAAI,KAAK,QAAQ,EAAE;AAClC;AACA,cAAA,IAAI4D,YAAY,CAACzD,KAAK,KAAK0D,WAAW,EAAE;AACtCH,gBAAAA,OAAO,GAAG,KAAK;AACf,gBAAA;AACF,cAAA;AACF,YAAA,CAAC,MAAM,IAAIE,YAAY,CAAC5D,IAAI,KAAK,OAAO,EAAE;AACxC;cACA,IAAI4D,YAAY,CAAC3D,IAAI,CAACuD,QAAQ,CAAC,GAAG,CAAC,EAAE;AACnC,gBAAA,MAAMO,SAAS,GAAGH,YAAY,CAAC3D,IAAI,CAACyB,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC;AAChDgB,gBAAAA,MAAM,CAACqB,SAAS,CAAC,GAAGZ,YAAY,CAACzB,KAAK,CAACiC,CAAC,CAAC,CAACK,IAAI,CAAC,GAAG,CAAC;AACnD,gBAAA,MAAM;AACR,cAAA;;AAEA;AACAtB,cAAAA,MAAM,CAACkB,YAAY,CAAC3D,IAAI,CAAC,GAAG4D,WAAW;AACzC,YAAA;AACF,UAAA;AAEA,UAAA,IAAIH,OAAO,EAAE;YACX,OAAO;cAAEnE,KAAK;AAAEmD,cAAAA;aAAQ;AAC1B,UAAA;QACF,CAAC,CAAC,OAAO5B,KAAK,EAAE;UACdT,OAAO,CAACC,IAAI,CAAC,CAAA,qBAAA,EAAwBf,KAAK,CAACG,IAAI,CAAA,CAAA,CAAG,EAAEoB,KAAK,CAAC;AAC1D,UAAA;AACF,QAAA;AACF,MAAA;AAEA,MAAA,OAAO,IAAI;IACb,CAAC,CAAC,OAAOA,KAAK,EAAE;AACdT,MAAAA,OAAO,CAACS,KAAK,CAAC,sBAAsB,EAAEA,KAAK,CAAC;AAC5C,MAAA,OAAO,IAAI;AACb,IAAA;AACF,EAAA;;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE,MAAMmD,QAAQA,CAACvE,IAAI,EAAEgD,MAAM,GAAG,EAAE,EAAE;AAChC,IAAA,IAAI,CAAChD,IAAI,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;AACrCW,MAAAA,OAAO,CAACS,KAAK,CAAC,oCAAoC,EAAEpB,IAAI,CAAC;AACzD,MAAA;AACF,IAAA;IAEA,IAAI;AACF;AACA,MAAA,IAAIgD,MAAM,IAAIwB,MAAM,CAACC,IAAI,CAACzB,MAAM,CAAC,CAACe,MAAM,GAAG,CAAC,EAAE;QAC5CS,MAAM,CAACC,IAAI,CAACzB,MAAM,CAAC,CAAC1B,OAAO,CAAE+B,GAAG,IAAK;AACnCrD,UAAAA,IAAI,GAAGA,IAAI,CAAC0E,OAAO,CAAC,IAAIrB,GAAG,CAAA,CAAE,EAAEsB,kBAAkB,CAAC3B,MAAM,CAACK,GAAG,CAAC,CAAC,CAAC;AACjE,QAAA,CAAC,CAAC;AACJ,MAAA;AAEA,MAAA,IAAI,IAAI,CAAC/D,IAAI,KAAK,MAAM,EAAE;AACxB,QAAA,IAAIU,IAAI,KAAK,GAAG,IAAIA,IAAI,KAAK,EAAE,EAAE;AAC/B;AACAe,UAAAA,MAAM,CAACc,QAAQ,CAACE,IAAI,GAAG,EAAE;AAC3B,QAAA,CAAC,MAAM;AACL;AACAhB,UAAAA,MAAM,CAACc,QAAQ,CAACE,IAAI,GAAG/B,IAAI;AAC7B,QAAA;AACF,MAAA,CAAC,MAAM,IAAI,IAAI,CAACV,IAAI,KAAK,OAAO,EAAE;QAChC,MAAM4C,SAAS,GAAG,IAAIC,eAAe,CAACpB,MAAM,CAACc,QAAQ,CAACI,MAAM,CAAC;AAC7D,QAAA,IAAIjC,IAAI,KAAK,GAAG,IAAIA,IAAI,KAAK,EAAE,EAAE;AAC/BkC,UAAAA,SAAS,CAACG,MAAM,CAAC,IAAI,CAAC9C,UAAU,CAAC;AACnC,QAAA,CAAC,MAAM;UACL2C,SAAS,CAAC0C,GAAG,CAAC,IAAI,CAACrF,UAAU,EAAES,IAAI,CAAC;AACtC,QAAA;AACA,QAAA,MAAM6E,QAAQ,GAAG3C,SAAS,CAACI,QAAQ,EAAE;AACrC,QAAA,MAAMwC,MAAM,GACV/D,MAAM,CAACc,QAAQ,CAACU,QAAQ,IAAIsC,QAAQ,GAAG,GAAG,GAAGA,QAAQ,GAAG,EAAE,CAAC;QAC7DE,OAAO,CAACC,SAAS,CAAC,EAAE,EAAE,EAAE,EAAEF,MAAM,CAAC;AACjC,QAAA,MAAM,IAAI,CAAChE,YAAY,EAAE;AAC3B,MAAA,CAAC,MAAM,IAAI,IAAI,CAACxB,IAAI,KAAK,SAAS,EAAE;QAClCyF,OAAO,CAACC,SAAS,CAAC,EAAE,EAAE,EAAE,EAAEhF,IAAI,CAAC;AAC/B,QAAA,MAAM,IAAI,CAACc,YAAY,EAAE;AAC3B,MAAA;IACF,CAAC,CAAC,OAAOM,KAAK,EAAE;MACdT,OAAO,CAACS,KAAK,CAAC,2BAA2B,EAAEpB,IAAI,EAAEoB,KAAK,CAAC;AACzD,IAAA;AACF,EAAA;;AAEA;AACF;AACA;AACA;AACA;EACE6D,QAAQA,CAACpF,KAAK,EAAE;AACd,IAAA,IAAI,CAACA,KAAK,IAAI,CAACA,KAAK,CAACG,IAAI,IAAI,CAACH,KAAK,CAACkD,SAAS,EAAE;AAC7C,MAAA,MAAM,IAAI9D,KAAK,CAAC,wDAAwD,CAAC;AAC3E,IAAA;IAEA,IAAI;AACF;MACAY,KAAK,CAACC,QAAQ,GAAG,IAAI,CAACC,qBAAqB,CAACF,KAAK,CAACG,IAAI,CAAC;AACvD,MAAA,IAAI,CAACX,MAAM,CAAC4B,IAAI,CAACpB,KAAK,CAAC;IACzB,CAAC,CAAC,OAAOuB,KAAK,EAAE;AACdT,MAAAA,OAAO,CAACS,KAAK,CAAC,qBAAqB,EAAEA,KAAK,CAAC;AAC3C,MAAA,MAAMA,KAAK;AACb,IAAA;AACF,EAAA;;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACE0B,EAAAA,sBAAsBA,CAACoC,IAAI,EAAEC,SAAS,EAAE;AACtC,IAAA,IAAIC,UAAU;AACd,IAAA,IAAI,OAAOF,IAAI,KAAK,QAAQ,EAAE;MAC5BE,UAAU,GAAG,IAAI,CAACtG,KAAK,CAACuG,WAAW,CAACjD,GAAG,CAAC8C,IAAI,CAAC;MAC7C,IAAI,CAACE,UAAU,EAAE;AACf,QAAA,MAAM,IAAInG,KAAK,CAAC,CAAA,WAAA,EAAciG,IAAI,mBAAmB,CAAC;AACxD,MAAA;AACF,IAAA,CAAC,MAAM;AACLE,MAAAA,UAAU,GAAGF,IAAI;AACnB,IAAA;;AAEA;AACA,IAAA,MAAMI,OAAO,GAAG;MAAE,GAAGF;KAAY;AACjC,IAAA,MAAMG,aAAa,GAAGD,OAAO,CAACE,KAAK;;AAEnC;AACAF,IAAAA,OAAO,CAACE,KAAK,GAAIC,GAAG,IAAK;MACvBA,GAAG,CAAC5F,KAAK,GAAGsF,SAAS;AACrB;MACA,MAAMO,gBAAgB,GAAG,IAAI,CAACnB,QAAQ,CAACoB,IAAI,CAAC,IAAI,CAAC;AACjDF,MAAAA,GAAG,CAAClB,QAAQ,GAAG,CAACvE,IAAI,EAAEgD,MAAM,KAAK0C,gBAAgB,CAAC1F,IAAI,EAAEgD,MAAM,CAAC;AAC/D;MACA,OAAOuC,aAAa,GAAGA,aAAa,CAACE,GAAG,CAAC,GAAG,EAAE;IAChD,CAAC;;AAED;IACA,IAAIH,OAAO,CAACM,QAAQ,EAAE;AACpB,MAAA,MAAMC,gBAAgB,GAAG;AAAE,QAAA,GAAGP,OAAO,CAACM;OAAU;AAChDN,MAAAA,OAAO,CAACM,QAAQ,GAAG,EAAE;;AAErB;MACApB,MAAM,CAACC,IAAI,CAACoB,gBAAgB,CAAC,CAACvE,OAAO,CAAEwE,QAAQ,IAAK;AAClD,QAAA,MAAMC,SAAS,GAAGF,gBAAgB,CAACC,QAAQ,CAAC;AAC5CR,QAAAA,OAAO,CAACM,QAAQ,CAACE,QAAQ,CAAC,GAAG,IAAI,CAAChD,sBAAsB,CACtDiD,SAAS,EACTZ,SACF,CAAC;AACH,MAAA,CAAC,CAAC;AACJ,IAAA;AAEA,IAAA,OAAOG,OAAO;AAChB,EAAA;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMU,WAAW,GAAG;AAClBzF,EAAAA,IAAI,EAAE,aAAa;AACnB0F,EAAAA,OAAOA,CAACnH,KAAK,EAAEC,OAAO,GAAG,EAAE,EAAE;IAC3B,IAAI;AACF;AACA,MAAA,MAAMM,MAAM,GAAGN,OAAO,CAACM,MAAM,IAAI,EAAE;MACnC,IAAI6G,cAAc,GAAG,CAAC;AAEtB7G,MAAAA,MAAM,CAACiC,OAAO,CAAEzB,KAAK,IAAK;AACxB,QAAA,IAAI,OAAOA,KAAK,CAACkD,SAAS,KAAK,QAAQ,EAAE;AACvC,UAAA,IAAIoD,QAAQ,GAAGtG,KAAK,CAACkD,SAAS,CAACxC,IAAI;UACnC,IAAI,CAAC4F,QAAQ,EAAE;AACbA,YAAAA,QAAQ,GAAG,mBAAmB,GAAGD,cAAc,EAAE;AACnD,UAAA;UACApH,KAAK,CAACiE,SAAS,CAACoD,QAAQ,EAAEtG,KAAK,CAACkD,SAAS,CAAC;UAC1ClD,KAAK,CAACkD,SAAS,GAAGoD,QAAQ;AAC5B,QAAA;AACF,MAAA,CAAC,CAAC;MAEF,MAAMC,MAAM,GAAG,IAAIxH,MAAM,CAACE,KAAK,EAAEC,OAAO,CAAC;MACzCD,KAAK,CAACsH,MAAM,GAAGA,MAAM;;AAErB;AACA,MAAA,MAAMC,eAAe,GAAGtH,OAAO,CAACuH,SAAS,KAAK,KAAK;AACnD,MAAA,IAAID,eAAe,EAAE;AACnBE,QAAAA,cAAc,CAAC,YAAY;UACzB,IAAI;AACF,YAAA,MAAMH,MAAM,CAAC1F,KAAK,EAAE;UACtB,CAAC,CAAC,OAAOU,KAAK,EAAE;AACdT,YAAAA,OAAO,CAACS,KAAK,CAAC,8BAA8B,EAAEA,KAAK,CAAC;AACtD,UAAA;AACF,QAAA,CAAC,CAAC;AACJ,MAAA;IACF,CAAC,CAAC,OAAOA,KAAK,EAAE;AACdT,MAAAA,OAAO,CAACS,KAAK,CAAC,uCAAuC,EAAEA,KAAK,CAAC;AAC7D,MAAA,MAAMA,KAAK;AACb,IAAA;AACF,EAAA;AACF;;;;"}