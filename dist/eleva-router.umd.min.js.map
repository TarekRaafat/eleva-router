{"version":3,"file":"eleva-router.umd.min.js","sources":["../src/index.js"],"sourcesContent":["/**\n * @class Router\n * @classdesc A Router Plugin for Eleva.js with Multiple Routing Modes\n *\n * This plugin provides client-side routing functionality for Eleva.js applications.\n * It supports hash-based (e.g. \"#pageName\"), query-based (e.g. \"?page=pageName\"),\n * and history-based (e.g. \"/pageName\") routing. The routing mode is configurable via\n * the plugin options.\n *\n * In addition to injecting route information (current path, query parameters,\n * and full URL) directly into the component's setup context as `route`, this plugin\n * also injects a `navigate` function so developers can programmatically navigate from within components.\n *\n * The router now supports dynamic route parameters (e.g. \"/users/:id\") which are passed\n * to the component via the route.params object.\n *\n * @param {Object} eleva - The Eleva instance.\n * @param {Object} options - Router configuration options.\n * @param {HTMLElement} options.layout - The app layout DOM element. The router will look for a view element\n *   (#{viewSelector} id, .{viewSelector} class, <{viewSelector}> element, or data-{viewSelector} attribute) within this layout to mount routed components.\n *   Priority is based on selection speed from fastest to slowest (micro-optimization). If no view element is found, the layout element itself will be used as the mounting target.\n * @param {string} [options.mode=\"hash\"] - The routing mode (\"hash\", \"query\", or \"history\").\n * @param {Array<Object>} options.routes - An array of route objects. Each route object should have:\n *   - {string} path - The URL path (e.g. \"/\" or \"/about\" or \"/users/:id\").\n *   - {string|Object} component - The component name (if registered globally) or a component definition.\n *   - {Object} [props] - Additional props to pass to the component.\n * @param {string} [options.queryParam=\"page\"] - The query parameter to use for routing.\n * @param {string} [options.viewSelector=\"view\"] - The selector name for the view element. Used to find elements like #{viewSelector}, .{viewSelector}, <{viewSelector}>, or data-{viewSelector}.\n * @param {Object} [options.defaultRoute] - A default route object used when no route matches.\n */\nclass Router {\n  constructor(eleva, options = {}) {\n    this.eleva = eleva;\n    this.layout = options.layout;\n    if (!this.layout) {\n      throw new Error(\"Router requires a layout DOM element in options.\");\n    }\n\n    // Find the view element within the layout, or use layout as fallback\n    this.viewSelector = options.viewSelector || \"view\"; // Default view selector\n    this.view =\n      this.layout.querySelector(`#${this.viewSelector}`) ||\n      this.layout.querySelector(`.${this.viewSelector}`) ||\n      this.layout.querySelector(this.viewSelector) ||\n      this.layout.querySelector(`[data-${this.viewSelector}]`) ||\n      this.layout;\n\n    this.routes = options.routes || [];\n    this.mode = options.mode || \"hash\"; // \"hash\", \"query\", or \"history\"\n    this.queryParam = options.queryParam || \"page\"; // The query parameter to use for routing\n    this.defaultRoute = options.defaultRoute || null;\n    this.eventListeners = []; // Track event listeners for cleanup\n    this.isStarted = false; // Track router state\n\n    // Validate routing mode\n    if (![\"hash\", \"query\", \"history\"].includes(this.mode)) {\n      throw new Error(\n        `Invalid routing mode: ${this.mode}. Must be \"hash\", \"query\", or \"history\".`\n      );\n    }\n\n    // Preprocess routes to identify parameter segments\n    this.routes = this.routes.map((route) => {\n      return {\n        ...route,\n        segments: this.parsePathIntoSegments(route.path),\n      };\n    });\n  }\n\n  /**\n   * Parses a path into segments for efficient parameter matching.\n   * @param {string} path - The route path pattern (e.g. \"/users/:id/profile\").\n   * @returns {Array} An array of segment objects with type and value.\n   * @private\n   */\n  parsePathIntoSegments(path) {\n    if (!path || typeof path !== \"string\") {\n      throw new Error(\"Route path must be a non-empty string\");\n    }\n\n    return path\n      .split(\"/\")\n      .filter(Boolean)\n      .map((segment) => {\n        if (segment.startsWith(\":\")) {\n          return { type: \"param\", name: segment.substring(1) };\n        }\n        return { type: \"static\", value: segment };\n      });\n  }\n\n  /**\n   * Starts the router by setting up event listeners and resolving the initial route.\n   * @returns {Promise<void>}\n   */\n  async start() {\n    if (this.isStarted) {\n      console.warn(\"Router is already started\");\n      return;\n    }\n\n    try {\n      if (this.mode === \"hash\") {\n        const hashHandler = async () => await this.routeChanged();\n        window.addEventListener(\"hashchange\", hashHandler);\n        this.eventListeners.push(() =>\n          window.removeEventListener(\"hashchange\", hashHandler)\n        );\n      } else if (this.mode === \"query\" || this.mode === \"history\") {\n        const popstateHandler = async () => await this.routeChanged();\n        window.addEventListener(\"popstate\", popstateHandler);\n        this.eventListeners.push(() =>\n          window.removeEventListener(\"popstate\", popstateHandler)\n        );\n      }\n\n      this.isStarted = true;\n      // Resolve the initial route\n      await this.routeChanged();\n    } catch (error) {\n      console.error(\"Failed to start router:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Stops the router and cleans up event listeners.\n   * @returns {Promise<void>}\n   */\n  async destroy() {\n    if (!this.isStarted) {\n      return;\n    }\n\n    try {\n      // Clean up event listeners\n      this.eventListeners.forEach((cleanup) => cleanup());\n      this.eventListeners = [];\n\n      // Unmount current component\n      const existingInstance = this.view._eleva_instance;\n      if (existingInstance) {\n        await existingInstance.unmount();\n      }\n\n      this.isStarted = false;\n    } catch (error) {\n      console.error(\"Error destroying router:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Called when the route changes. Extracts the current route based on the routing mode,\n   * parses the URL query, and mounts the corresponding component. Injects route data and\n   * a navigation function directly into the component's setup context.\n   * @returns {Promise<void>}\n   */\n  async routeChanged() {\n    try {\n      let path, queryString, fullUrl;\n\n      if (this.mode === \"hash\") {\n        fullUrl = window.location.href;\n        let hash = window.location.hash.slice(1) || \"\";\n        [path, queryString] = hash.split(\"?\");\n        // If path is empty, default to \"/\"\n        path = path || \"/\";\n      } else if (this.mode === \"query\") {\n        fullUrl = window.location.href;\n        const search = window.location.search; // e.g. ?page=about&foo=bar\n        const urlParams = new URLSearchParams(search);\n        path = urlParams.get(this.queryParam) || \"\";\n        urlParams.delete(this.queryParam);\n        queryString = urlParams.toString();\n        path = path || \"/\";\n      } else if (this.mode === \"history\") {\n        fullUrl = window.location.href;\n        path = window.location.pathname || \"/\";\n        queryString = window.location.search\n          ? window.location.search.slice(1)\n          : \"\";\n      }\n\n      // Normalize the path: Ensure it starts with '/'\n      if (path.charAt(0) !== \"/\") {\n        path = \"/\" + path;\n      }\n\n      // Unmount the previous component instance if it exists\n      const existingInstance = this.view._eleva_instance;\n      if (existingInstance) {\n        try {\n          await existingInstance.unmount();\n        } catch (error) {\n          console.warn(\"Error unmounting previous component:\", error);\n        }\n      }\n\n      const query = this.parseQuery(queryString);\n\n      // Try to find a matching route for the current path\n      const matchResult = this.matchRoute(path);\n\n      // Use defaultRoute if no matching route is found\n      if (!matchResult && this.defaultRoute) {\n        try {\n          const wrappedComponent = this.wrapComponentWithRoute(\n            this.defaultRoute.component,\n            {\n              path,\n              query,\n              fullUrl,\n              params: {},\n              matchedRoute: this.defaultRoute.path,\n            }\n          );\n          const props = this.defaultRoute.props || {};\n          await this.eleva.mount(this.view, wrappedComponent, props);\n        } catch (error) {\n          console.error(\"Error mounting default route component:\", error);\n        }\n      } else if (matchResult) {\n        try {\n          const { route, params } = matchResult;\n          const wrappedComponent = this.wrapComponentWithRoute(\n            route.component,\n            {\n              path,\n              query,\n              fullUrl,\n              params,\n              matchedRoute: route.path,\n            }\n          );\n          const props = route.props || {};\n          await this.eleva.mount(this.view, wrappedComponent, props);\n        } catch (error) {\n          console.error(\"Error mounting route component:\", error);\n        }\n      } else {\n        console.warn(`No route found for path: ${path}`);\n      }\n    } catch (error) {\n      console.error(\"Error in route change:\", error);\n    }\n  }\n\n  /**\n   * Parses a query string into an object.\n   * @param {string} queryString - The query string portion of a URL.\n   * @returns {Object} An object containing key-value pairs for query parameters.\n   */\n  parseQuery(queryString) {\n    const query = {};\n    if (!queryString) return query;\n\n    try {\n      queryString.split(\"&\").forEach((pair) => {\n        const [key, value] = pair.split(\"=\");\n        if (key) {\n          query[decodeURIComponent(key)] = value\n            ? decodeURIComponent(value)\n            : \"\";\n        }\n      });\n    } catch (error) {\n      console.warn(\"Error parsing query string:\", error);\n    }\n\n    return query;\n  }\n\n  /**\n   * Finds a matching route for the specified path.\n   * Supports dynamic route parameters (e.g. \"/users/:id\").\n   * @param {string} path - The current path extracted from the URL.\n   * @returns {Object|null} An object containing the matched route and extracted parameters, or null if no match is found.\n   */\n  matchRoute(path) {\n    // Input validation\n    if (!path || typeof path !== \"string\") {\n      console.warn(\"Invalid path provided to matchRoute:\", path);\n      return null;\n    }\n\n    try {\n      // Handle root path special case\n      if (path === \"/\") {\n        const rootRoute = this.routes.find((route) => route.path === \"/\");\n        if (rootRoute) {\n          return { route: rootRoute, params: {} };\n        }\n        return null;\n      }\n\n      // Split the current path into segments for matching\n      const pathSegments = path.split(\"/\").filter(Boolean);\n\n      // Try to match against all routes\n      for (const route of this.routes) {\n        try {\n          // Skip the root route as we've already handled it\n          if (route.path === \"/\") continue;\n\n          const routeSegments = route.segments;\n\n          // Quick length check (except for catch-all routes with wildcard segments)\n          const hasCatchAll = routeSegments.some(\n            (s) => s.type === \"param\" && s.name.endsWith(\"*\")\n          );\n          if (!hasCatchAll && routeSegments.length !== pathSegments.length) {\n            continue;\n          }\n\n          // Try to match segment by segment\n          const params = {};\n          let isMatch = true;\n\n          for (let i = 0; i < routeSegments.length; i++) {\n            const routeSegment = routeSegments[i];\n            const pathSegment = pathSegments[i];\n\n            // Path is shorter than route definition\n            if (pathSegment === undefined) {\n              isMatch = false;\n              break;\n            }\n\n            if (routeSegment.type === \"static\") {\n              // For static segments, direct comparison\n              if (routeSegment.value !== pathSegment) {\n                isMatch = false;\n                break;\n              }\n            } else if (routeSegment.type === \"param\") {\n              // Handle catch-all parameters (e.g. \":path*\")\n              if (routeSegment.name.endsWith(\"*\")) {\n                const paramName = routeSegment.name.slice(0, -1);\n                params[paramName] = pathSegments.slice(i).join(\"/\");\n                break; // This will match all remaining segments\n              }\n\n              // For parameter segments, store the value\n              params[routeSegment.name] = pathSegment;\n            }\n          }\n\n          if (isMatch) {\n            return { route, params };\n          }\n        } catch (error) {\n          console.warn(`Error matching route ${route.path}:`, error);\n          continue;\n        }\n      }\n\n      return null;\n    } catch (error) {\n      console.error(\"Error in matchRoute:\", error);\n      return null;\n    }\n  }\n\n  /**\n   * Programmatically navigates to the specified route.\n   * Updates the URL based on the routing mode and triggers route resolution.\n   * @param {string} path - The target route path.\n   * @param {Object} [params] - Route parameters to inject into the path.\n   * @returns {Promise<void>}\n   */\n  async navigate(path, params = {}) {\n    if (!path || typeof path !== \"string\") {\n      console.error(\"Invalid path provided to navigate:\", path);\n      return;\n    }\n\n    try {\n      // If params are provided, replace parameter placeholders in the path\n      if (params && Object.keys(params).length > 0) {\n        Object.keys(params).forEach((key) => {\n          path = path.replace(`:${key}`, encodeURIComponent(params[key]));\n        });\n      }\n\n      if (this.mode === \"hash\") {\n        if (path === \"/\" || path === \"\") {\n          // For root path, clear hash completely\n          window.location.hash = \"\";\n        } else {\n          // For other paths, set hash (this triggers hashchange automatically)\n          window.location.hash = path;\n        }\n      } else if (this.mode === \"query\") {\n        const urlParams = new URLSearchParams(window.location.search);\n        if (path === \"/\" || path === \"\") {\n          urlParams.delete(this.queryParam);\n        } else {\n          urlParams.set(this.queryParam, path);\n        }\n        const newQuery = urlParams.toString();\n        const newUrl =\n          window.location.pathname + (newQuery ? \"?\" + newQuery : \"\");\n        history.pushState({}, \"\", newUrl);\n        await this.routeChanged();\n      } else if (this.mode === \"history\") {\n        history.pushState({}, \"\", path);\n        await this.routeChanged();\n      }\n    } catch (error) {\n      console.error(\"Error navigating to path:\", path, error);\n    }\n  }\n\n  /**\n   * Adds a new route to the router.\n   * @param {Object} route - The route object to add.\n   * @returns {void}\n   */\n  addRoute(route) {\n    if (!route || !route.path || !route.component) {\n      throw new Error(\"Route must have both 'path' and 'component' properties\");\n    }\n\n    try {\n      // Preprocess the route to identify parameter segments\n      route.segments = this.parsePathIntoSegments(route.path);\n      this.routes.push(route);\n    } catch (error) {\n      console.error(\"Error adding route:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Wraps a component definition so that its setup function receives the route information\n   * and the navigate function directly in the context.\n   * @param {string|Object} comp - The component name (if registered globally) or component definition.\n   * @param {Object} routeInfo - An object containing route information (path, query, fullUrl, params).\n   * @returns {Object} A new component definition with an augmented setup function.\n   */\n  wrapComponentWithRoute(comp, routeInfo) {\n    let definition;\n    if (typeof comp === \"string\") {\n      definition = this.eleva._components.get(comp);\n      if (!definition) {\n        throw new Error(`Component \"${comp}\" not registered.`);\n      }\n    } else {\n      definition = comp;\n    }\n\n    // Create a shallow copy of the component definition\n    const wrapped = { ...definition };\n    const originalSetup = wrapped.setup;\n\n    // Override the setup function to inject route information\n    wrapped.setup = (ctx) => {\n      ctx.route = routeInfo;\n      // Bind navigate with the router instance and wrap it to support params\n      const originalNavigate = this.navigate.bind(this);\n      ctx.navigate = (path, params) => originalNavigate(path, params);\n      // Inject route information and navigation function into the context\n      return originalSetup ? originalSetup(ctx) : {};\n    };\n\n    // If this component has children, we need to modify its children handling\n    if (wrapped.children) {\n      const originalChildren = { ...wrapped.children };\n      wrapped.children = {};\n\n      // For each child component, wrap it to also include route information\n      Object.keys(originalChildren).forEach((childKey) => {\n        const childComp = originalChildren[childKey];\n        wrapped.children[childKey] = this.wrapComponentWithRoute(\n          childComp,\n          routeInfo\n        );\n      });\n    }\n\n    return wrapped;\n  }\n}\n\n/**\n * @typedef {Object} RouteDefinition\n * @property {string} path - The URL path (e.g., \"/\" or \"/about\" or \"/users/:id\").\n * @property {string|Object} component - The component name (if registered globally) or a component definition.\n * @property {Object} [props] - Additional properties to pass to the routed component.\n */\n\n/**\n * @typedef {Object} RouterOptions\n * @property {HTMLElement} layout - The app layout DOM element. The router will look for a view element\n *   (with data-view attribute, .view class, or #view id) within this layout to mount routed components.\n *   If no view element is found, the layout element itself will be used as the mounting target.\n * @property {string} [mode=\"hash\"] - The routing mode: \"hash\", \"query\", or \"history\".\n * @property {Array<RouteDefinition>} routes - An array of route definitions.\n * @property {RouteDefinition} [defaultRoute] - A default route object to use when no route matches.\n * @property {boolean} [autoStart=true] - Whether to automatically start the router.\n * If set to false, the router must be manually started using eleva.router.start().\n */\n\n/**\n * @namespace ElevaRouter\n * @description ElevaRouter is the official router plugin for Eleva.js.\n *\n * It provides client-side routing functionality with support for multiple routing modes,\n * automatic component registration, and route information injection into the setup context.\n *\n * Installs the ElevaRouter plugin into an Eleva.js instance.\n * Automatically registers routed components if provided as definitions.\n *\n * @param {Object} eleva - The Eleva instance.\n * @param {RouterOptions} options - Router configuration options.\n * @param {boolean} [options.autoStart=true] - Whether to automatically start the router.\n * If set to false, the router must be manually started using eleva.router.start().\n * @returns {void}\n */\nconst ElevaRouter = {\n  name: \"ElevaRouter\",\n  install(eleva, options = {}) {\n    try {\n      // Automatically register routed components if provided as definitions\n      const routes = options.routes || [];\n      let autoRegCounter = 0;\n\n      routes.forEach((route) => {\n        if (typeof route.component === \"object\") {\n          let compName = route.component.name;\n          if (!compName) {\n            compName = \"AutoRegComponent_\" + autoRegCounter++;\n          }\n          eleva.component(compName, route.component);\n          route.component = compName;\n        }\n      });\n\n      const router = new Router(eleva, options);\n      eleva.router = router;\n\n      // Handle auto-start asynchronously without blocking plugin installation\n      const shouldAutoStart = options.autoStart !== false;\n      if (shouldAutoStart) {\n        queueMicrotask(async () => {\n          try {\n            await router.start();\n          } catch (error) {\n            console.error(\"Failed to auto-start router:\", error);\n          }\n        });\n      }\n    } catch (error) {\n      console.error(\"Failed to install ElevaRouter plugin:\", error);\n      throw error;\n    }\n  },\n};\n\nexport default ElevaRouter;\n"],"names":["Router","constructor","eleva","options","this","layout","Error","viewSelector","view","querySelector","routes","mode","queryParam","defaultRoute","eventListeners","isStarted","includes","map","route","segments","parsePathIntoSegments","path","split","filter","Boolean","segment","startsWith","type","name","substring","value","start","hashHandler","async","routeChanged","window","addEventListener","push","removeEventListener","popstateHandler","error","destroy","forEach","cleanup","existingInstance","_eleva_instance","unmount","queryString","fullUrl","location","href","hash","slice","search","urlParams","URLSearchParams","get","delete","toString","pathname","charAt","query","parseQuery","matchResult","matchRoute","wrappedComponent","wrapComponentWithRoute","component","params","matchedRoute","props","mount","pair","key","decodeURIComponent","rootRoute","find","pathSegments","routeSegments","some","s","endsWith","length","isMatch","i","routeSegment","pathSegment","undefined","join","navigate","Object","keys","replace","encodeURIComponent","set","newQuery","newUrl","history","pushState","addRoute","comp","routeInfo","definition","_components","wrapped","originalSetup","setup","ctx","originalNavigate","bind","children","originalChildren","childKey","install","autoRegCounter","compName","router","autoStart","queueMicrotask"],"mappings":"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"}